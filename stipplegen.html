<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StippleGen - Weighted Voronoi Stippling</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #00d4ff;
        }
        .controls {
            background: #16213e;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
        }
        .control-group input[type="range"] {
            width: 100%;
            accent-color: #00d4ff;
        }
        .control-group input[type="file"] {
            font-size: 12px;
        }
        .control-group select {
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: #0f3460;
            color: #fff;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #00d4ff;
            color: #000;
        }
        .btn-primary:hover {
            background: #00a8cc;
        }
        .btn-secondary {
            background: #e94560;
            color: #fff;
        }
        .btn-secondary:hover {
            background: #c73e54;
        }
        .btn-tertiary {
            background: #0f3460;
            color: #fff;
        }
        .btn-tertiary:hover {
            background: #1a4a7a;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .canvas-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .canvas-wrapper {
            background: #fff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        .canvas-wrapper h3 {
            background: #16213e;
            color: #fff;
            padding: 10px;
            text-align: center;
            font-size: 14px;
        }
        canvas {
            display: block;
        }
        .status {
            text-align: center;
            padding: 15px;
            background: #16213e;
            border-radius: 10px;
            margin-top: 20px;
        }
        .status-text {
            font-size: 14px;
            color: #00d4ff;
        }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #0f3460;
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #e94560);
            width: 0%;
            transition: width 0.3s;
        }
        .value-display {
            font-weight: bold;
            color: #00d4ff;
        }
        .button-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .info {
            font-size: 11px;
            color: #666;
            margin-top: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® StippleGen</h1>
        <p style="text-align: center; margin-bottom: 20px; color: #888;">
            Weighted Voronoi Stippling - Transform images into dot art
        </p>

        <div class="controls">
            <div class="control-group">
                <label>Load Image</label>
                <input type="file" id="imageInput" accept="image/*">
            </div>

            <div class="control-group">
                <label>Number of Points: <span class="value-display" id="pointsValue">5000</span></label>
                <input type="range" id="numPoints" min="500" max="20000" value="5000" step="100">
            </div>

            <div class="control-group">
                <label>Min Dot Size: <span class="value-display" id="minDotValue">1</span>px</label>
                <input type="range" id="minDotSize" min="0.5" max="5" value="1" step="0.5">
            </div>

            <div class="control-group">
                <label>Max Dot Size: <span class="value-display" id="maxDotValue">4</span>px</label>
                <input type="range" id="maxDotSize" min="1" max="10" value="4" step="0.5">
            </div>

            <div class="control-group">
                <label>Iterations: <span class="value-display" id="iterValue">50</span></label>
                <input type="range" id="iterations" min="10" max="200" value="50" step="10">
            </div>

            <div class="control-group">
                <label>Output Mode</label>
                <select id="outputMode">
                    <option value="dots">Filled Dots</option>
                    <option value="circles">Circle Outlines</option>
                    <option value="uniform">Uniform Size</option>
                </select>
            </div>

            <div class="control-group">
                <label>Background</label>
                <select id="bgColor">
                    <option value="white">White</option>
                    <option value="black">Black</option>
                    <option value="cream">Cream</option>
                </select>
            </div>

            <div class="control-group button-row">
                <button class="btn-primary" id="startBtn" disabled>‚ñ∂ Start Stippling</button>
                <button class="btn-secondary" id="stopBtn" disabled>‚èπ Stop</button>
                <button class="btn-tertiary" id="exportSvgBtn" disabled>üì• Export SVG</button>
            </div>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h3>Original Image</h3>
                <canvas id="sourceCanvas" width="600" height="600"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h3>Stippled Result</h3>
                <canvas id="outputCanvas" width="600" height="600"></canvas>
            </div>
        </div>

        <div class="status">
            <div class="status-text" id="statusText">Load an image to begin</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <p class="info">
            Based on "Weighted Voronoi Stippling" by Adrian Secord (NPAR 2002) and Evil Mad Scientist's StippleGen.
            Uses Lloyd's relaxation algorithm with brightness-weighted centroids.
        </p>
    </div>

    <!-- d3-delaunay for Voronoi computation -->
    <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6"></script>

    <script>
        // ============================================
        // StippleGen - Weighted Voronoi Stippling
        // ============================================

        class StippleGenerator {
            constructor() {
                this.sourceCanvas = document.getElementById('sourceCanvas');
                this.outputCanvas = document.getElementById('outputCanvas');
                this.sourceCtx = this.sourceCanvas.getContext('2d');
                this.outputCtx = this.outputCanvas.getContext('2d');

                this.imageData = null;
                this.brightnessData = null;
                this.points = [];
                this.running = false;
                this.iteration = 0;

                this.width = 600;
                this.height = 600;

                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('imageInput').addEventListener('change', (e) => this.loadImage(e));
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('exportSvgBtn').addEventListener('click', () => this.exportSVG());

                // Update value displays
                const sliders = [
                    ['numPoints', 'pointsValue'],
                    ['minDotSize', 'minDotValue'],
                    ['maxDotSize', 'maxDotValue'],
                    ['iterations', 'iterValue']
                ];

                sliders.forEach(([sliderId, displayId]) => {
                    document.getElementById(sliderId).addEventListener('input', (e) => {
                        document.getElementById(displayId).textContent = e.target.value;
                    });
                });
            }

            loadImage(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Calculate dimensions maintaining aspect ratio
                        const maxSize = 600;
                        let w = img.width;
                        let h = img.height;

                        if (w > h) {
                            if (w > maxSize) {
                                h = (h * maxSize) / w;
                                w = maxSize;
                            }
                        } else {
                            if (h > maxSize) {
                                w = (w * maxSize) / h;
                                h = maxSize;
                            }
                        }

                        this.width = Math.floor(w);
                        this.height = Math.floor(h);

                        // Resize canvases
                        this.sourceCanvas.width = this.width;
                        this.sourceCanvas.height = this.height;
                        this.outputCanvas.width = this.width;
                        this.outputCanvas.height = this.height;

                        // Draw source image
                        this.sourceCtx.drawImage(img, 0, 0, this.width, this.height);

                        // Extract and process image data
                        this.imageData = this.sourceCtx.getImageData(0, 0, this.width, this.height);
                        this.computeBrightnessData();

                        // Clear output
                        this.clearOutput();

                        document.getElementById('startBtn').disabled = false;
                        this.updateStatus('Image loaded. Click Start to begin stippling.');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            computeBrightnessData() {
                // Create brightness array (0 = black, 255 = white)
                // Apply slight blur for smoother results
                const data = this.imageData.data;
                this.brightnessData = new Float32Array(this.width * this.height);

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const i = (y * this.width + x) * 4;
                        // Convert to grayscale using luminance formula
                        const brightness = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                        this.brightnessData[y * this.width + x] = brightness;
                    }
                }

                // Apply box blur for smoother point distribution
                this.brightnessData = this.boxBlur(this.brightnessData, this.width, this.height, 2);
            }

            boxBlur(data, width, height, radius) {
                const result = new Float32Array(width * height);
                const size = radius * 2 + 1;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let sum = 0;
                        let count = 0;

                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;

                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    sum += data[ny * width + nx];
                                    count++;
                                }
                            }
                        }

                        result[y * width + x] = sum / count;
                    }
                }

                return result;
            }

            initializePoints() {
                // Use rejection sampling based on darkness
                // Darker areas = higher probability of placing a point
                const numPoints = parseInt(document.getElementById('numPoints').value);
                this.points = [];

                let attempts = 0;
                const maxAttempts = numPoints * 100;

                while (this.points.length < numPoints && attempts < maxAttempts) {
                    attempts++;

                    const x = Math.random() * this.width;
                    const y = Math.random() * this.height;

                    // Get brightness at this position (with interpolation)
                    const brightness = this.sampleBrightness(x, y);

                    // Probability of accepting point is inversely proportional to brightness
                    // (darker = more likely to accept)
                    const density = 1 - (brightness / 255);

                    if (Math.random() < density) {
                        this.points.push({ x, y });
                    }
                }

                // If we couldn't place enough points, add some randomly
                while (this.points.length < numPoints) {
                    this.points.push({
                        x: Math.random() * this.width,
                        y: Math.random() * this.height
                    });
                }

                this.updateStatus(`Initialized ${this.points.length} points`);
            }

            sampleBrightness(x, y) {
                // Bilinear interpolation for smooth brightness sampling
                const x0 = Math.floor(x);
                const y0 = Math.floor(y);
                const x1 = Math.min(x0 + 1, this.width - 1);
                const y1 = Math.min(y0 + 1, this.height - 1);

                const fx = x - x0;
                const fy = y - y0;

                const b00 = this.brightnessData[y0 * this.width + x0];
                const b10 = this.brightnessData[y0 * this.width + x1];
                const b01 = this.brightnessData[y1 * this.width + x0];
                const b11 = this.brightnessData[y1 * this.width + x1];

                const b0 = b00 * (1 - fx) + b10 * fx;
                const b1 = b01 * (1 - fx) + b11 * fx;

                return b0 * (1 - fy) + b1 * fy;
            }

            computeVoronoi() {
                // Create Delaunay triangulation and Voronoi diagram
                const flatPoints = this.points.flatMap(p => [p.x, p.y]);
                this.delaunay = d3.Delaunay.from(this.points, p => p.x, p => p.y);
                this.voronoi = this.delaunay.voronoi([0, 0, this.width, this.height]);
            }

            computeWeightedCentroids() {
                // For each Voronoi cell, compute weighted centroid based on darkness
                const newPoints = [];

                for (let i = 0; i < this.points.length; i++) {
                    const cell = this.voronoi.cellPolygon(i);

                    if (!cell || cell.length < 3) {
                        // Keep original point if cell is invalid
                        newPoints.push({ ...this.points[i] });
                        continue;
                    }

                    // Get bounding box of cell
                    let minX = Infinity, minY = Infinity;
                    let maxX = -Infinity, maxY = -Infinity;

                    for (const [px, py] of cell) {
                        minX = Math.min(minX, px);
                        minY = Math.min(minY, py);
                        maxX = Math.max(maxX, px);
                        maxY = Math.max(maxY, py);
                    }

                    minX = Math.max(0, Math.floor(minX));
                    minY = Math.max(0, Math.floor(minY));
                    maxX = Math.min(this.width - 1, Math.ceil(maxX));
                    maxY = Math.min(this.height - 1, Math.ceil(maxY));

                    // Sample pixels within cell and compute weighted centroid
                    let sumX = 0, sumY = 0, sumWeight = 0;

                    // Use adaptive sampling based on cell size
                    const cellWidth = maxX - minX;
                    const cellHeight = maxY - minY;
                    const step = Math.max(1, Math.floor(Math.min(cellWidth, cellHeight) / 10));

                    for (let y = minY; y <= maxY; y += step) {
                        for (let x = minX; x <= maxX; x += step) {
                            if (this.pointInPolygon(x, y, cell)) {
                                // Weight is inversely proportional to brightness (darker = more weight)
                                const brightness = this.brightnessData[y * this.width + x];
                                const weight = 256 - brightness; // Darker pixels have higher weight

                                sumX += x * weight;
                                sumY += y * weight;
                                sumWeight += weight;
                            }
                        }
                    }

                    if (sumWeight > 0) {
                        newPoints.push({
                            x: sumX / sumWeight,
                            y: sumY / sumWeight
                        });
                    } else {
                        // Fallback to geometric centroid
                        const cx = cell.reduce((sum, p) => sum + p[0], 0) / cell.length;
                        const cy = cell.reduce((sum, p) => sum + p[1], 0) / cell.length;
                        newPoints.push({ x: cx, y: cy });
                    }
                }

                this.points = newPoints;
            }

            pointInPolygon(x, y, polygon) {
                // Ray casting algorithm
                let inside = false;
                const n = polygon.length;

                for (let i = 0, j = n - 1; i < n; j = i++) {
                    const xi = polygon[i][0], yi = polygon[i][1];
                    const xj = polygon[j][0], yj = polygon[j][1];

                    if (((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                        inside = !inside;
                    }
                }

                return inside;
            }

            render() {
                const bgColor = document.getElementById('bgColor').value;
                const outputMode = document.getElementById('outputMode').value;
                const minDotSize = parseFloat(document.getElementById('minDotSize').value);
                const maxDotSize = parseFloat(document.getElementById('maxDotSize').value);

                // Set background
                const bgColors = {
                    white: '#ffffff',
                    black: '#000000',
                    cream: '#f5f5dc'
                };

                this.outputCtx.fillStyle = bgColors[bgColor];
                this.outputCtx.fillRect(0, 0, this.width, this.height);

                // Set dot color (inverse of background)
                const dotColor = bgColor === 'black' ? '#ffffff' : '#000000';
                this.outputCtx.fillStyle = dotColor;
                this.outputCtx.strokeStyle = dotColor;

                // Draw points
                for (const point of this.points) {
                    // Size based on darkness at point location
                    const brightness = this.sampleBrightness(point.x, point.y);

                    let radius;
                    if (outputMode === 'uniform') {
                        radius = (minDotSize + maxDotSize) / 2;
                    } else {
                        // Darker = larger dot
                        const t = 1 - (brightness / 255);
                        radius = minDotSize + t * (maxDotSize - minDotSize);
                    }

                    this.outputCtx.beginPath();
                    this.outputCtx.arc(point.x, point.y, radius, 0, Math.PI * 2);

                    if (outputMode === 'circles') {
                        this.outputCtx.lineWidth = 0.5;
                        this.outputCtx.stroke();
                    } else {
                        this.outputCtx.fill();
                    }
                }
            }

            async start() {
                if (!this.imageData) return;

                this.running = true;
                this.iteration = 0;

                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('exportSvgBtn').disabled = true;

                const maxIterations = parseInt(document.getElementById('iterations').value);

                // Initialize points
                this.updateStatus('Initializing points...');
                this.initializePoints();

                // Run Lloyd's relaxation
                while (this.running && this.iteration < maxIterations) {
                    this.iteration++;

                    // Compute Voronoi diagram
                    this.computeVoronoi();

                    // Move points to weighted centroids
                    this.computeWeightedCentroids();

                    // Render current state
                    this.render();

                    // Update progress
                    const progress = (this.iteration / maxIterations) * 100;
                    document.getElementById('progressFill').style.width = progress + '%';
                    this.updateStatus(`Iteration ${this.iteration}/${maxIterations}`);

                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                this.running = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('exportSvgBtn').disabled = false;

                this.updateStatus(`Complete! ${this.points.length} points after ${this.iteration} iterations`);
            }

            stop() {
                this.running = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('exportSvgBtn').disabled = false;
                this.updateStatus('Stopped by user');
            }

            clearOutput() {
                this.outputCtx.fillStyle = '#ffffff';
                this.outputCtx.fillRect(0, 0, this.width, this.height);
            }

            updateStatus(text) {
                document.getElementById('statusText').textContent = text;
            }

            exportSVG() {
                if (this.points.length === 0) return;

                const bgColor = document.getElementById('bgColor').value;
                const outputMode = document.getElementById('outputMode').value;
                const minDotSize = parseFloat(document.getElementById('minDotSize').value);
                const maxDotSize = parseFloat(document.getElementById('maxDotSize').value);

                const bgColors = {
                    white: '#ffffff',
                    black: '#000000',
                    cream: '#f5f5dc'
                };

                const dotColor = bgColor === 'black' ? '#ffffff' : '#000000';

                let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${this.width}" height="${this.height}" viewBox="0 0 ${this.width} ${this.height}">
  <rect width="100%" height="100%" fill="${bgColors[bgColor]}"/>
  <g fill="${outputMode === 'circles' ? 'none' : dotColor}" stroke="${outputMode === 'circles' ? dotColor : 'none'}" stroke-width="0.5">
`;

                for (const point of this.points) {
                    const brightness = this.sampleBrightness(point.x, point.y);
                    let radius;

                    if (outputMode === 'uniform') {
                        radius = (minDotSize + maxDotSize) / 2;
                    } else {
                        const t = 1 - (brightness / 255);
                        radius = minDotSize + t * (maxDotSize - minDotSize);
                    }

                    svg += `    <circle cx="${point.x.toFixed(2)}" cy="${point.y.toFixed(2)}" r="${radius.toFixed(2)}"/>\n`;
                }

                svg += `  </g>
</svg>`;

                // Download SVG
                const blob = new Blob([svg], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'stipple.svg';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.updateStatus('SVG exported!');
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.stippleGen = new StippleGenerator();
        });
    </script>
</body>
</html>
